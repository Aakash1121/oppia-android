syntax = "proto3";

package model;

option java_package = "org.oppia.android.app.model";
option java_multiple_files = true;

// Structure for a fraction object.
message Fraction {
  bool is_negative = 1;
  int32 whole_number = 2;
  int32 numerator = 3;
  int32 denominator = 4;
}

// Represents a mathematical expression such as 1+2. The only expression currently supported is a
// binary operation.
message MathExpression {
  // TODO: document inclusive
  int32 parse_start_index = 1;
  // TODO: document exclusive
  int32 parse_end_index = 2;

  oneof expression_type {
    Real constant = 3;
    string variable = 4;
    MathBinaryOperation binary_operation = 5;
    MathUnaryOperation unary_operation = 6;
    MathFunctionCall function_call = 7;
    MathExpression group = 8;
  }
}

message MathEquation {
  MathExpression left_side = 1;
  MathExpression right_side = 2;
}

message MathBinaryOperation {
  enum Operator {
    OPERATOR_UNSPECIFIED = 0;
    // Represents adding two values, e.g.: 1+x.
    ADD = 1;
    // Represents subtracting two values, e.g.: x-2.
    SUBTRACT = 2;
    // Represents multiplying two values, e.g.: x*y.
    MULTIPLY = 3;
    // Represents dividing two values, e.g.: 1/x.
    DIVIDE = 4;
    // Represents taking the exponentiation of one value by another, e.g.: x^2.
    EXPONENTIATE = 5;
  }

  Operator operator = 1;
  MathExpression left_operand = 2;
  MathExpression right_operand = 3;
  bool is_implicit = 4;
}

message MathUnaryOperation {
  enum Operator {
    OPERATOR_UNSPECIFIED = 0;
    // Represents negating a value, e.g.: -y.
    NEGATE = 1;
    // Represents indicating a value as positive, e.g.: +y.
    POSITIVE = 2;
  }

  Operator operator = 1;
  MathExpression operand = 2;
}

message MathFunctionCall {
  enum FunctionType {
    FUNCTION_UNSPECIFIED = 0;
    SQUARE_ROOT = 1;
  }

  FunctionType function_type = 1;
  MathExpression argument = 2;
}

message Real {
  oneof real_type {
    Fraction rational = 1;
    // Represents a decimal value. Technically these can sometimes be rational, but given IEEE-754
    // rounding errors we need to treat these values as irrational and non-factorable.
    double irrational = 2;
    int32 integer = 3;
  }
}

// Represents a list of comparable mathematics operations. 'Comparable' here means that this
// structure provides a trivial way to compare commutative operations (i.e. by extracting terms from
// multiple subsequent commutative operations into lists that can be deterministically sorted). This
// structure is meant to provide a means to compare two expressions without considering
// associativity or commutativity (though the latter requires the operation lists stored within this
// structure to be sorted before using standard proto equals checking).
message ComparableOperationList {
  message ComparableOperation {
    // Treat this operation (e.g. x) as negated (e.g. -x).
    bool is_negated = 1;

    // Treat this operation (e.g. x) as a multiplicative inverse (e.g. 1/x).
    bool is_inverted = 2;

    oneof comparison_type {
      CommutativeAccumulation commutative_accumulation = 3;
      NonCommutativeOperation non_commutative_operation = 4;
      Real constant_term = 5;
      string variable_term = 6;
    }
  }
  // Represents an accumulation of operations (such as a summation or product). This helps simplify
  // comparison across commutative boundaries by collecting terms into sortable lists, such as the
  // expression 1+2+3 becoming [1,2,3] and trivially comparable to [3,2,1] from 3+2+1.
  //
  // Subsequent subtractions are treated as additions with each term arithmetically negated (i.e.
  // f(x)=-x). Similarly, divisions are considered multiplications with each divisor being
  // multiplicatively inverted (i.e. the reciprocal function: f(x)=1/x).
  message CommutativeAccumulation {
    enum AccumulationType {
      ACCUMULATION_TYPE_UNSPECIFIED = 0;
      SUMMATION = 1;
      PRODUCT = 2;
    }

    AccumulationType accumulation_type = 1;
    repeated ComparableOperation combined_operations = 2;
  }
  message NonCommutativeOperation {
    oneof operation_type {
      BinaryOperation exponentiation = 1;
      ComparableOperation square_root = 2;
    }

    message BinaryOperation {
      ComparableOperation left_operand = 1;
      ComparableOperation right_operand = 2;
    }
  }

  ComparableOperation root_operation = 1;
}

message Polynomial {
  repeated Term term = 1;

  message Term {
    Real coefficient = 1;
    repeated Variable variable = 2;

    message Variable {
      string name = 1;
      uint32 power = 2;
    }
  }
}
